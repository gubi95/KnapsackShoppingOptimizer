\documentclass[a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\selectlanguage{polish}

\usepackage[margin=1 in, includefoot]{geometry}
\pagenumbering{arabic}
\setcounter{page}{2}
\usepackage{graphicx}
\usepackage{float}
\usepackage{multirow}
\usepackage[space]{grffile}
\usepackage{xcolor, listings}
\usepackage{mathtools}
\lstset{
basicstyle=\footnotesize\ttfamily,
numbers=left,
numberstyle=\tiny,
numbersep=5pt,
tabsize=2,
extendedchars=true,
breaklines=true,
commentstyle=\color{green},
keywordstyle=\color{blue},
identifierstyle=\color{black},
showspaces=false,
showstringspaces=false,
}
\lstdefinestyle{sharpc}{language=[Sharp]C, frame=lr, rulecolor=\color{blue!80!black}}
%nowa strona przed kazdym section
\let\oldsection\section
\renewcommand\section{\clearpage\oldsection}
\newcommand\tab[1][1cm]{\hspace*{#1}}
\begin{document}
\begin{titlepage}
\begin{center}
\huge{\textsc{Politechnika Wrocławska\\Wydział Elektroniki}}
\line(1,0){400}\\
[1 cm]
\textsc{\Huge {Zarządzanie w Systemach i Sieciach Komputerowych}}\\
[0.5 cm]
\textsc{\Large {Optymalizacja listy zakupów pod względem ceny}}\\
\end{center}
\vfill
\vfill
\hspace{0.5 cm}
\begin{minipage}[t]{.4\textwidth}%
\flushleft
\textsc{\Large{Autorzy :}}\\
\Large{Rafał Gubała }\\
\Large{Jakub Małyjasiak}
\end{minipage}%
\begin{minipage}[t]{.5\textwidth}%
\flushright
\textsc{\Large{Prowadzący :}}\\
\Large{dr inż. Robert Wójcik}\\
\end{minipage}%
\vfill
\begin{center}
\normalsize{Wrocław 2017}
\end{center}
\end{titlepage}

\tableofcontents 
\listoffigures

\section{Wstęp}
\subsection{Cel projektu}
\large
Celem projektu było opracowanie i stworzenie aplikacji na platformę Windows implementującą algorytmy optymalizujące listy zakupowe pod względem ceny produktów z różnych sklepów.
\subsection{Zakres projektu}
\large
Założenie projektowe obejmowały stworzenie aplikacji okienkowej posiadającej następujące funkcjonalności:
\begin{itemize}
\item Dodawanie, edycja oraz usuwanie sklepów
\item Dodawanie, edycja oraz usuwanie produktów
\item Tworzenie list zakupowych z wybranymi produktami
\item Optymalizacja list zakupowych algorytmami \textbf{Shop-Enum} oraz \textbf{Product-Enum}
\item Mierzenie czasu wykonywania się poszczególnych algorytmów
\item Zapisywanie i wczytywanie wprowadzonych danych
\end{itemize}
\section{Sformułowanie problemu}
\subsection{Podstawowe założenia}
\large
Rozwiązywany problem dotyczy zakupów internetowych i zminimalizowania kosztów poniesionych przy zakupie wybranych produktów w wybranych sklepach. Pojedyncza osoba szuka określonego zestawu produktów $N = \{1,...,n\}$ w $m$ sklepach. Każdy sklep posiada swój koszt wysyłki $d_i$ oraz każdy podzbiór produktów $N_i$ może być skojarzony z wieloma sklepami. Oprócz tego, każdy produkt należący do wybranego podzbioru $N_i$ posiada swoją cenę $c_{ji}$, gdzie $j \in N_i$ Rozwiązaniem problemu jest znalezienie takiego zestawu produktów z co najmniej jednego sklepu, aby sumaryczna wartość zakupów była jak najmniejsza.
\subsection{Opis wariantów problemu}
\subsubsection{Problem decyzyjny}
W przypadku obu algorytmów problem decyzyjny sprowadza się do pytania, czy istnieje podzbiór produktów $N_i$ i odpowiadający mu zbiór sklepów $M_i$, dla którego sumaryczny koszt zakupu będzie równy $k$. Rozwiązanie owego problemu będzie polegało na przeszukaniu zbioru wszystkich sklepów w poszukiwaniu produktów w podzbioru $N_i$. Jeśli wszystkie produkty udało się znaleźć, to sumując ceny wszystkich przedmiotów z cenami wysyłki w odpowiednich sklepach możemy udzielić odpowiedzi na postawione pytanie.
\subsubsection{Problem optymalizacyjny}
Mając na uwadze sformułowany wcześniej problem decyzyjny możemy prosto sformułować odpowiadający mu problem optymalizacyjny. W tym przypadku brzmi on: \textit{Ile wynosi najniższy koszt zakupu przedmiotów ze zbioru $N_i$ w zadanym zbiorze sklepów.} Warto zauważyć, że problem w istocie nie jest trywialny. Ważną komplikacją jest fakt, że pod uwagę trzeba wziąć koszt wysyłki danego produktu, co sprawia, że proste przeszukanie sklepów w celu znalezienia najtańszych ofert dla danego produktu nie ma sensu. Czasami bardziej opłacalne może okazać się kupienie droższego produktu, jeśli pozwoli to uniknąć poniesienia kosztów wysyłki w innym sklepie. 
\subsection{Zastosowane algorytmy}
Posiłkując się materiałami zawartymi w [3] do rozwiązania problemu wykorzystaliśmy algorytmy \textit{SHOP-ENUM} oraz \textit{PRODUCT-ENUM}. Oba pozwalają znaleźć optymalne rozwiązanie, ale dzieje się to kosztem złożoności obliczeniowej.

Podstawowym założeniem algorytmu \textit{SHOP-ENUM} jest skupienie się na sklepach, zamiast na produktach. Zakładamy tutaj, że analizie poddamy każdy możliwy podzbiór sklepów, co pozwoli w trywialny sposób przeszukać kolekcję w celu znalezienia najtańszej oferty na dany produkt z punktu widzenia pojedynczej iteracji. Jest to możliwe dzięki temu, że koszt wysyłki nie gra tutaj roli. Ze względu na to, że analizie zostanie poddany każdy podzbiór sklepów, czyli każda możliwa kombinacja kosztów wysyłki, możemy w naiwny sposób szukać podzbioru produktów o najniższej cenie. Koszt wysyłki zwiększa ową cenę o odpowiednią wartość i w ten sposób otrzymujemy rezultat działania algorytmu.
\vspace{0.5 cm}
\lstset{style=sharpc}
\begin{lstlisting}
foreach permutation of stores
		foreach product in shoppingList
			cheapestProduct <- stores.findCheapest(product)
			resultList.add(cheapestProduct)
		
		if resultList.Cost < bestSolution.Cost then
			bestSolution <- resultList
\end{lstlisting}
\vspace{0.5 cm}

Algorytm \textit{PRODUCT-ENUM} to przeciwieństwo wspomnianego wcześniej algorytmu \textit{SHOP-ENUM}. Tutaj uwagę skupia się na produktach. Podstawą algorytmu jest założenie, że tym razem zamiast analizować każdy możliwy podzbiór sklepów, stworzymy każdą pożliwą kombinację produktów. Pseudokod trafnie obrazuje ten zamysł:

\vspace{0.5 cm}
\lstset{style=sharpc}
\begin{lstlisting}
Permutate(shoppingList, stores, itemIndex) {
	if itemIndex < shoppingList.Count then
		foreach store in stores 
			product <-  store.findProduct(shoppingList[itemIndex])
			if product.Amount < shoppingList[itemIndex].Amount then continue
			shoppingList[itemIndex].setNewPrice(product.Price)
			shoppingList[itemIndex].setNewStore(product.Store)
		
			Permutate(shoppingList, stores, itemIndex + 1)
	else
		if shoppingList.Cost < bestSolution.Cost then
			bestSolution <- shoppingList
}
\end{lstlisting}
\vspace{0.5 cm}
Widać tutaj jasno, że naszym zamiarem będzie stworzenie każdej możliwej kombinacji produktów, jak już wcześniej wspomniano. W praktyce oznacza to wykorzystanie rekurencji, która pozwoli na każdej pozycji na liście zakupów przeanalizować wariant, w którym produkt bierzemy kolejno z każdego sklepu, w którym jest dostępny
\subsection{Analiza złożoności obliczeniowej algorytmów}
\subsubsection{Algorytm SHOP-ENUM}
\subsubsection{Algorytm PRODUCT-ENUM}

\section{Projekt aplikacji}
\subsection{Wykorzystywane technologie i narzędzia projektowania}
Do stworzenie projektu zostały użyte następujące technologie i narzędzia:
\begin{itemize}
\item Język programowania: C\#
\item Środowisko programistyczne: Visual Studio 2015, Visual Studio 2017
\item XAML - język opisu interfejsu użytkownika
\item Inne: WPF, NewtonSoft: JSON.Net
\end{itemize}
\subsection{Struktura programu}
W projekcie został zastosowany wzorzec obiektowy. Aplikacja została napisana z rozdzieleniem interfejsu użytkownika oraz logiki samych algorytmów minimalizujących w postaci odrębnych modułów (projektów w solucji). Zabieg ten miał na celu wyodrębnić moduł algorytmiczny, aby można go było łatwo przenieść w przyszłości do innego projektu np. w postaci skompilowanej biblioteki.
\begin{flushleft}
Program zapisuje dane do pliku tekstowego w popularnym formacie JSON. Umożliwia to łatwy odczyt i parsowanie tekstu do obiektów w programie. Jest to symulacja bazy danych. Obsługa danych została zrealizowana jako wzorzec fabryki, każda encja posiada swoją fabrykę z metodami takimi jak: \textit{getAll}, \textit{getByID}, \textit{create}, \textit{update} oraz \textit{delete}.
\end{flushleft}
\subsection{Koncepcja działania algorytmów}
\subsubsection{Algorytm SHOP-ENUM}
\subsubsection{Algorytm PRODUCT-ENUM}
\subsection{Diagram klas}
\subsection{Struktura danych wejściowych}
\subsection{Struktura wyników}

\section{Implementacja systemu}
\subsection{Wybrane klasy}
\subsubsection{ShoppingList}
\lstset{style=sharpc}
\begin{lstlisting}
public class ShoppingList
{
    public Guid ShoppingListID { get; set; }
    public string Name { get; set; }
		public Dictionary<Guid, int> ProductIdToAmountDictionary { get; set; }
}
\end{lstlisting}
\begin{flushleft}
Powyższa klasa reprezentuje listę zakupową. Posiada ona 3 pola: 
\begin{itemize}
\item \textit{ShoppingListID}: identyfikator zrealizowany za pomocą klasy \textbf{Guid} (zapewnia to bardzo dużą losowość)
\item \textit{Name}: nazwa list zakupowej
\item \textit{ProductIdToAmountDictionary}: słownik przyporządkowujący identyfikator produktu na liście do jego ilości
\end{itemize}
\end{flushleft}
\subsubsection{Store}
\lstset{style=sharpc}
\begin{lstlisting}
public class Store
{           
		public Guid StoreID { get; set; }
    public string Name { get; set; }
    public List<StorePosition> Positions { get; set; }
    public decimal ShipmentCost { get; set; }
    public string ShipmentCostFormatted
    {
    		get
        {
        		return this.ShipmentCost.ToString("C");
        }
     }
}
\end{lstlisting}
\begin{flushleft}
Powyższa klasa reprezentuje sklep. Posiada ona 5 pól: 
\begin{itemize}
\item \textit{StoreID}: identyfikator zrealizowany za pomocą klasy \textbf{Guid} 
\item \textit{Name}: nazwa sklepu
\item \textit{Positions}: lista przechowujące pozycje (produkty) sklepowe
\item \textit{ShipmentCost}: cena wysyłki
\item \textit{ShipmentCostFormatted}: sformatowana cena wysyłki, np. "15,00 zł"
\end{itemize}
\end{flushleft}
\subsubsection{Product}
\lstset{style=sharpc}
\begin{lstlisting}
public class Product
{     
		public Guid ProductID { get; set; }      
    public string Name { get; set; }        
}
\end{lstlisting}
\begin{flushleft}
Powyższa klasa reprezentuje produkt. Posiada ona 2 pola: 
\begin{itemize}
\item \textit{ProductID}: identyfikator zrealizowany za pomocą klasy \textbf{Guid} 
\item \textit{Name}: nazwa produktu
\end{itemize}
\end{flushleft}
\subsection{Realizacja algorytmów wyznaczania rozwiązań}
\subsubsection{Algorytm SHOP-ENUM}
\subsubsection{Algorytm PRODUCT-ENUM}
\subsection{Metoda odczytu danych wejściowych}
\subsection{Metoda prezentacji i zapisu wyników}

\section{Testowanie poprawności i ocena rozwiązań}
\subsection{Testy jednostkowe}
\subsection{Weryfikacja poprawności działania algorytmów - przykłady}
\subsubsection{Algorytm SHOP-ENUM}
\subsubsection{Algorytm PRODUCT-ENUM}
\subsection{Analiza czasów wykonania algorytmów}
\subsection{Wnioski z testów i badań}

\section{Podsumowanie}
Reasumując, wykonując ten projekt nauczyliśmy się wielu rzeczy. Przede wszystkim poznaliśmy ciekawe i praktyczne algorytmy do rozwiązywanego przez nas problemu, a także rozwinęliśmy swoją wiedzę na temat .NET oraz tworzenia aplikacji okienkowych z użyciem technologii XAML. Ważnym elementem naszej pracy była również zdolność komunikacji oraz pójścia na kompromis w niektórych sytuacjach. Ważna okazała się również synchronizacja pracy i planowanie kolejnych zadań w taki sposób, aby nie przeszkadzać sobie nawzajem.
\begin{thebibliography}{9}

\bibitem{greene}
  Greene Jennifer, Stellman Andrew 
  \emph{C\#. Rusz głową!}.
  Helion,
  2014.
  
\bibitem{wpf}
	Nathan Adam
	\emph{WPF 4.5 Księga eksperta}. Helion, 2015.  
  
\bibitem{article_algorithms}
	Jacek Błażewicz, Mikhail Y. Kovalyov, Jędrzej Musiał, Andrzej P. Urbanski, Adam Wojciechowski
	\emph{Internet shopping optimization problem}.
	Int. J. Appl. Math. Comput. Sci., 2010, Vol. 20, No. 2, 385–390 
	
  \end{thebibliography}
\end{document}
